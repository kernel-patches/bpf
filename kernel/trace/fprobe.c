// SPDX-License-Identifier: GPL-2.0
/*
 * fprobe - Simple ftrace probe wrapper for function entry.
 */
#define pr_fmt(fmt) "fprobe: " fmt

#include <linux/fprobe.h>
#include <linux/kallsyms.h>
#include <linux/kprobes.h>
#include <linux/rethook.h>
#include <linux/slab.h>
#include <linux/sort.h>

struct fprobe_rethook_node {
	struct rethook_node node;
	unsigned long entry_ip;
};

static void fprobe_handler(unsigned long ip, unsigned long parent_ip,
			   struct ftrace_ops *ops, struct ftrace_regs *fregs)
{
	struct fprobe_rethook_node *fpr;
	struct rethook_node *rh;
	struct fprobe *fp;
	int bit;

	fp = container_of(ops, struct fprobe, ftrace);
	if (fprobe_disabled(fp))
		return;

	bit = ftrace_test_recursion_trylock(ip, parent_ip);
	if (bit < 0) {
		fp->nmissed++;
		return;
	}

	if (fp->entry_handler)
		fp->entry_handler(fp, ip, ftrace_get_regs(fregs));

	if (fp->exit_handler) {
		rh = rethook_try_get(fp->rethook);
		if (!rh) {
			fp->nmissed++;
			goto out;
		}
		fpr = container_of(rh, struct fprobe_rethook_node, node);
		fpr->entry_ip = ip;
		rethook_hook(rh, ftrace_get_regs(fregs));
	}

out:
	ftrace_test_recursion_unlock(bit);
}
NOKPROBE_SYMBOL(fprobe_handler);

static void fprobe_exit_handler(struct rethook_node *rh, void *data,
				struct pt_regs *regs)
{
	struct fprobe *fp = (struct fprobe *)data;
	struct fprobe_rethook_node *fpr;

	if (!data)
		return;

	fpr = container_of(rh, struct fprobe_rethook_node, node);

	fp->exit_handler(fp, fpr->entry_ip, regs);
}
NOKPROBE_SYMBOL(fprobe_exit_handler);

static int convert_func_addresses(struct fprobe *fp)
{
	unsigned int i;

	if (!fp->syms)
		return 0;

	fp->addrs = kcalloc(fp->nentry, sizeof(*fp->addrs), GFP_KERNEL);
	if (!fp->addrs)
		return -ENOMEM;

	for (i = 0; i < fp->nentry; i++) {
		fp->addrs[i] = kallsyms_lookup_name(fp->syms[i]);
		if (!fp->addrs[i])
			return -ENOENT;
	}

	return 0;
}

/**
 * register_fprobe() - Register fprobe to ftrace
 * @fp: A fprobe data structure to be registered.
 *
 * This expects the user set @fp::entry_handler, @fp::syms or @fp:addrs,
 * and @fp::nentry.
 * Note that you do not set both of @fp::addrs and @fp::syms.
 */
int register_fprobe(struct fprobe *fp)
{
	unsigned int i, size;
	int ret;

	if (!fp || !fp->nentry || (!fp->syms && !fp->addrs) ||
	    (fp->syms && fp->addrs))
		return -EINVAL;

	ret = convert_func_addresses(fp);
	if (ret < 0)
		return ret;

	fp->nmissed = 0;
	fp->ftrace.func = fprobe_handler;
	fp->ftrace.flags = FTRACE_OPS_FL_SAVE_REGS;

	/* Initialize rethook if needed */
	if (fp->exit_handler) {
		size = fp->nentry * num_possible_cpus() * 2;
		fp->rethook = rethook_alloc((void *)fp, fprobe_exit_handler);
		for (i = 0; i < size; i++) {
			struct rethook_node *node;

			node = kzalloc(sizeof(struct fprobe_rethook_node), GFP_KERNEL);
			if (!node) {
				rethook_free(fp->rethook);
				ret = -ENOMEM;
				goto out;
			}
			rethook_add_node(fp->rethook, node);
		}
	} else
		fp->rethook = NULL;

	ret = ftrace_set_filter_ips(&fp->ftrace, fp->addrs, fp->nentry, 0, 0);
	if (!ret)
		ret = register_ftrace_function(&fp->ftrace);

out:
	if (ret < 0 && fp->syms) {
		kfree(fp->addrs);
		fp->addrs = NULL;
	}

	return ret;
}
EXPORT_SYMBOL_GPL(register_fprobe);

/**
 * unregister_fprobe() - Unregister fprobe from ftrace
 * @fp: A fprobe data structure to be unregistered.
 *
 * Unregister fprobe (and remove ftrace hooks from the function entries).
 * If the @fp::addrs are generated by register_fprobe(), it will be removed
 * automatically.
 */
int unregister_fprobe(struct fprobe *fp)
{
	int ret;

	if (!fp || !fp->nentry || !fp->addrs)
		return -EINVAL;

	ret = unregister_ftrace_function(&fp->ftrace);
	if (ret < 0)
		return ret;

	if (fp->rethook) {
		/* Make sure to clear rethook->data before freeing. */
		WRITE_ONCE(fp->rethook->data, NULL);
		barrier();
		rethook_free(fp->rethook);
	}
	if (fp->syms) {
		kfree(fp->addrs);
		fp->addrs = NULL;
	}
	return ret;
}
EXPORT_SYMBOL_GPL(unregister_fprobe);
