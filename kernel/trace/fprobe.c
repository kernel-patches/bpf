// SPDX-License-Identifier: GPL-2.0
/*
 * fprobe - Simple ftrace probe wrapper for function entry.
 */
#define pr_fmt(fmt) "fprobe: " fmt

#include <linux/fprobe.h>
#include <linux/kallsyms.h>
#include <linux/kprobes.h>
#include <linux/slab.h>
#include <linux/sort.h>

static void fprobe_handler(unsigned long ip, unsigned long parent_ip,
			   struct ftrace_ops *ops, struct ftrace_regs *fregs)
{
	struct fprobe *fp;
	int bit;

	fp = container_of(ops, struct fprobe, ftrace);
	if (fprobe_disabled(fp))
		return;

	bit = ftrace_test_recursion_trylock(ip, parent_ip);
	if (bit < 0) {
		fp->nmissed++;
		return;
	}

	if (fp->entry_handler)
		fp->entry_handler(fp, ip, ftrace_get_regs(fregs));

	ftrace_test_recursion_unlock(bit);
}
NOKPROBE_SYMBOL(fprobe_handler);

static int convert_func_addresses(struct fprobe *fp)
{
	unsigned int i;

	if (!fp->syms)
		return 0;

	fp->addrs = kcalloc(fp->nentry, sizeof(*fp->addrs), GFP_KERNEL);
	if (!fp->addrs)
		return -ENOMEM;

	for (i = 0; i < fp->nentry; i++) {

		fp->addrs[i] = kallsyms_lookup_name(fp->syms[i]);
		if (!fp->addrs[i])
			return -ENOENT;
	}

	return 0;
}

/**
 * register_fprobe() - Register fprobe to ftrace
 * @fp: A fprobe data structure to be registered.
 *
 * This expects the user set @fp::entry_handler, @fp::syms or @fp:addrs,
 * and @fp::nentry.
 * Note that you do not set both of @fp::addrs and @fp::syms.
 */
int register_fprobe(struct fprobe *fp)
{
	int ret;

	if (!fp || !fp->nentry || (!fp->syms && !fp->addrs) ||
	    (fp->syms && fp->addrs))
		return -EINVAL;

	ret = convert_func_addresses(fp);
	if (ret < 0)
		return ret;

	fp->nmissed = 0;
	fp->ftrace.func = fprobe_handler;
	fp->ftrace.flags = FTRACE_OPS_FL_SAVE_REGS;

	ret = ftrace_set_filter_ips(&fp->ftrace, fp->addrs, fp->nentry, 0, 0);
	if (!ret)
		ret = register_ftrace_function(&fp->ftrace);

	if (ret < 0 && fp->syms) {
		kfree(fp->addrs);
		fp->addrs = NULL;
	}

	return ret;
}
EXPORT_SYMBOL_GPL(register_fprobe);

/**
 * unregister_fprobe() - Unregister fprobe from ftrace
 * @fp: A fprobe data structure to be unregistered.
 *
 * Unregister fprobe (and remove ftrace hooks from the function entries).
 * If the @fp::addrs are generated by register_fprobe(), it will be removed
 * automatically.
 */
int unregister_fprobe(struct fprobe *fp)
{
	int ret;

	if (!fp || !fp->nentry || !fp->addrs)
		return -EINVAL;

	ret = unregister_ftrace_function(&fp->ftrace);

	if (!ret && fp->syms) {
		kfree(fp->addrs);
		fp->addrs = NULL;
	}
	return ret;
}
EXPORT_SYMBOL_GPL(unregister_fprobe);
