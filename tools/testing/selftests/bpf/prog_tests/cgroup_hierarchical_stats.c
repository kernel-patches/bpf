// SPDX-License-Identifier: GPL-2.0-only
/*
 * Functions to manage eBPF programs attached to cgroup subsystems
 *
 * Copyright 2022 Google LLC.
 */
#include <errno.h>
#include <sys/types.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <unistd.h>

#include <test_progs.h>
#include <bpf/libbpf.h>
#include <bpf/bpf.h>

#include "cgroup_helpers.h"
#include "cgroup_hierarchical_stats.skel.h"

#define PAGE_SIZE 4096
#define MB(x) (x << 20)

#define BPFFS_ROOT "/sys/fs/bpf/"
#define BPFFS_VMSCAN BPFFS_ROOT"vmscan/"

#define CG_ROOT_NAME "root"
#define CG_ROOT_ID 1

#define CGROUP_PATH(p, n) {.path = #p"/"#n, .name = #n}

static struct {
	const char *path, *name;
	unsigned long long id;
	int fd;
} cgroups[] = {
	CGROUP_PATH(/, test),
	CGROUP_PATH(/test, child1),
	CGROUP_PATH(/test, child2),
	CGROUP_PATH(/test/child1, child1_1),
	CGROUP_PATH(/test/child1, child1_2),
	CGROUP_PATH(/test/child2, child2_1),
	CGROUP_PATH(/test/child2, child2_2),
};

#define N_CGROUPS ARRAY_SIZE(cgroups)
#define N_NON_LEAF_CGROUPS 3

int root_cgroup_fd;
bool mounted_bpffs;

static int read_from_file(const char *path, char *buf, size_t size)
{
	int fd, len;

	fd = open(path, O_RDONLY);
	if (fd < 0) {
		log_err("Open %s", path);
		return -errno;
	}
	len = read(fd, buf, size);
	if (len < 0)
		log_err("Read %s", path);
	else
		buf[len] = 0;
	close(fd);
	return len < 0 ? -errno : 0;
}

static int setup_bpffs(void)
{
	int err;

	/* Mount bpffs */
	err = mount("bpf", BPFFS_ROOT, "bpf", 0, NULL);
	mounted_bpffs = !err;
	if (!ASSERT_OK(err && errno != EBUSY, "mount bpffs"))
		return err;

	/* Create a directory to contain stat files in bpffs */
	err = mkdir(BPFFS_VMSCAN, 0755);
	ASSERT_OK(err, "mkdir bpffs");
	return err;
}

static void cleanup_bpffs(void)
{
	/* Remove created directory in bpffs */
	ASSERT_OK(rmdir(BPFFS_VMSCAN), "rmdir "BPFFS_VMSCAN);

	/* Unmount bpffs, if it wasn't already mounted when we started */
	if (mounted_bpffs)
		return;
	ASSERT_OK(umount(BPFFS_ROOT), "unmount bpffs");
}

static int setup_cgroups(void)
{
	int i, fd, err;

	err = setup_cgroup_environment();
	if (!ASSERT_OK(err, "setup_cgroup_environment"))
		return err;

	root_cgroup_fd = get_root_cgroup();
	if (!ASSERT_GE(root_cgroup_fd, 0, "get_root_cgroup"))
		return root_cgroup_fd;

	for (i = 0; i < N_CGROUPS; i++) {
		fd = create_and_get_cgroup(cgroups[i].path);
		if (!ASSERT_GE(fd, 0, "create_and_get_cgroup"))
			return fd;

		cgroups[i].fd = fd;
		cgroups[i].id = get_cgroup_id(cgroups[i].path);

		/*
		 * Enable memcg controller for the entire hierarchy.
		 * Note that stats are collected for all cgroups in a hierarchy
		 * with memcg enabled anyway, but are only exposed for cgroups
		 * that have memcg enabled.
		 */
		if (i < N_NON_LEAF_CGROUPS) {
			err = enable_controllers(cgroups[i].path, "memory");
			if (!ASSERT_OK(err, "enable_controllers"))
				return err;
		}
	}
	return 0;
}

static void cleanup_cgroups(void)
{
	close(root_cgroup_fd);
	for (int i = 0; i < N_CGROUPS; i++)
		close(cgroups[i].fd);
	cleanup_cgroup_environment();
}


static int setup_hierarchy(void)
{
	return setup_bpffs() || setup_cgroups();
}

static void destroy_hierarchy(void)
{
	cleanup_cgroups();
	cleanup_bpffs();
}

static void alloc_anon(size_t size)
{
	char *buf, *ptr;

	buf = malloc(size);
	for (ptr = buf; ptr < buf + size; ptr += PAGE_SIZE)
		*ptr = 0;
	free(buf);
}

static int induce_vmscan(void)
{
	char size[128];
	int i, err;

	/*
	 * Set memory.high for test parent cgroup to 1 MB to throttle
	 * allocations and invoke reclaim in children.
	 */
	snprintf(size, 128, "%d", MB(1));
	err = write_cgroup_file(cgroups[0].path, "memory.high",	size);
	if (!ASSERT_OK(err, "write memory.high"))
		return err;
	/*
	 * In every leaf cgroup, run a memory hog for a few seconds to induce
	 * reclaim then kill it.
	 */
	for (i = N_NON_LEAF_CGROUPS; i < N_CGROUPS; i++) {
		pid_t pid = fork();

		if (pid == 0) {
			/* Join cgroup in the parent process workdir */
			join_parent_cgroup(cgroups[i].path);

			/* Allocate more memory than memory.high */
			alloc_anon(MB(2));
			exit(0);
		} else {
			/* Wait for child to cause reclaim then kill it */
			if (!ASSERT_GT(pid, 0, "fork"))
				return pid;
			sleep(2);
			kill(pid, SIGKILL);
			waitpid(pid, NULL, 0);
		}
	}
	return 0;
}

static unsigned long long get_cgroup_vmscan_delay(unsigned long long cgroup_id,
						  const char *file_name)
{
	char buf[128], path[128];
	unsigned long long vmscan = 0, id = 0;
	int err;

	/* For every cgroup, read the file generated by cgroup_iter */
	snprintf(path, 128, "%s%s", BPFFS_VMSCAN, file_name);
	err = read_from_file(path, buf, 128);
	if (!ASSERT_OK(err, "read cgroup_iter"))
		return 0;

	/* Check the output file formatting */
	ASSERT_EQ(sscanf(buf, "cg_id: %llu, total_vmscan_delay: %llu\n",
			 &id, &vmscan), 2, "output format");

	/* Check that the cgroup_id is displayed correctly */
	ASSERT_EQ(id, cgroup_id, "cgroup_id");
	/* Check that the vmscan reading is non-zero */
	ASSERT_GT(vmscan, 0, "vmscan_reading");
	return vmscan;
}

static void check_vmscan_stats(void)
{
	int i;
	unsigned long long vmscan_readings[N_CGROUPS], vmscan_root;

	for (i = 0; i < N_CGROUPS; i++)
		vmscan_readings[i] = get_cgroup_vmscan_delay(cgroups[i].id,
							     cgroups[i].name);

	/* Read stats for root too */
	vmscan_root = get_cgroup_vmscan_delay(CG_ROOT_ID, CG_ROOT_NAME);

	/* Check that child1 == child1_1 + child1_2 */
	ASSERT_EQ(vmscan_readings[1], vmscan_readings[3] + vmscan_readings[4],
		  "child1_vmscan");
	/* Check that child2 == child2_1 + child2_2 */
	ASSERT_EQ(vmscan_readings[2], vmscan_readings[5] + vmscan_readings[6],
		  "child2_vmscan");
	/* Check that test == child1 + child2 */
	ASSERT_EQ(vmscan_readings[0], vmscan_readings[1] + vmscan_readings[2],
		  "test_vmscan");
	/* Check that root >= test */
	ASSERT_GE(vmscan_root, vmscan_readings[1], "root_vmscan");
}

static int setup_cgroup_iter(struct cgroup_hierarchical_stats *obj, int cgroup_fd,
			     const char *file_name)
{
	DECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);
	union bpf_iter_link_info linfo = {};
	struct bpf_link *link;
	char path[128];
	int err;

	/*
	 * Create an iter link, parameterized by cgroup_fd.
	 * We only want to traverse one cgroup, so set the traversal order to
	 * "pre", and return 1 from dump_vmscan to stop iteration after the
	 * first cgroup.
	 */
	linfo.cgroup.cgroup_fd = cgroup_fd;
	linfo.cgroup.traversal_order = BPF_ITER_CGROUP_PRE;
	opts.link_info = &linfo;
	opts.link_info_len = sizeof(linfo);
	link = bpf_program__attach_iter(obj->progs.dump_vmscan, &opts);
	if (!ASSERT_OK_PTR(link, "attach iter"))
		return libbpf_get_error(link);

	/* Pin the link to a bpffs file */
	snprintf(path, 128, "%s%s", BPFFS_VMSCAN, file_name);
	err = bpf_link__pin(link, path);
	ASSERT_OK(err, "pin cgroup_iter");
	return err;
}

static int setup_progs(struct cgroup_hierarchical_stats **skel)
{
	int i, err;
	struct bpf_link *link;
	struct cgroup_hierarchical_stats *obj;

	obj = cgroup_hierarchical_stats__open_and_load();
	if (!ASSERT_OK_PTR(obj, "open_and_load"))
		return libbpf_get_error(obj);

	/* Attach cgroup_iter program that will dump the stats to cgroups */
	for (i = 0; i < N_CGROUPS; i++) {
		err = setup_cgroup_iter(obj, cgroups[i].fd, cgroups[i].name);
		if (!ASSERT_OK(err, "setup_cgroup_iter"))
			return err;
	}
	/* Also dump stats for root */
	err = setup_cgroup_iter(obj, root_cgroup_fd, CG_ROOT_NAME);
	if (!ASSERT_OK(err, "setup_cgroup_iter"))
		return err;

	/* Attach rstat flusher */
	link = bpf_program__attach(obj->progs.vmscan_flush);
	if (!ASSERT_OK_PTR(link, "attach rstat"))
		return libbpf_get_error(link);

	/* Attach tracing programs that will calculate vmscan delays */
	link = bpf_program__attach(obj->progs.vmscan_start);
	if (!ASSERT_OK_PTR(obj, "attach raw_tracepoint"))
		return libbpf_get_error(obj);

	link = bpf_program__attach(obj->progs.vmscan_end);
	if (!ASSERT_OK_PTR(obj, "attach raw_tracepoint"))
		return libbpf_get_error(obj);

	*skel = obj;
	return 0;
}

void destroy_progs(struct cgroup_hierarchical_stats *skel)
{
	char path[128];
	int i;

	for (i = 0; i < N_CGROUPS; i++) {
		/* Delete files in bpffs that cgroup_iters are pinned in */
		snprintf(path, 128, "%s%s", BPFFS_VMSCAN,
			 cgroups[i].name);
		ASSERT_OK(remove(path), "remove cgroup_iter pin");
	}

	/* Delete root file in bpffs */
	snprintf(path, 128, "%s%s", BPFFS_VMSCAN, CG_ROOT_NAME);
	ASSERT_OK(remove(path), "remove cgroup_iter root pin");
	cgroup_hierarchical_stats__destroy(skel);
}

void test_cgroup_hierarchical_stats(void)
{
	struct cgroup_hierarchical_stats *skel = NULL;

	if (setup_hierarchy())
		goto hierarchy_cleanup;
	if (setup_progs(&skel))
		goto cleanup;
	if (induce_vmscan())
		goto cleanup;
	check_vmscan_stats();
cleanup:
	destroy_progs(skel);
hierarchy_cleanup:
	destroy_hierarchy();
}
