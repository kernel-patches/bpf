// SPDX-License-Identifier: GPL-2.0-only
/*
 * Functions to manage eBPF programs attached to cgroup subsystems
 *
 * Copyright 2022 Google LLC.
 */
#include <errno.h>
#include <sys/types.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <unistd.h>

#include <bpf/libbpf.h>
#include <bpf/bpf.h>
#include <test_progs.h>

#include "cgroup_helpers.h"
#include "cgroup_vmscan.skel.h"

#define PAGE_SIZE 4096
#define MB(x) (x << 20)

#define BPFFS_ROOT "/sys/fs/bpf/"
#define BPFFS_VMSCAN BPFFS_ROOT"vmscan/"

#define CG_ROOT_NAME "root"
#define CG_ROOT_ID 1

#define CGROUP_PATH(p, n) {.name = #n, .path = #p"/"#n}

static struct {
	const char *name, *path;
	unsigned long long id;
	int fd;
} cgroups[] = {
	CGROUP_PATH(/, test),
	CGROUP_PATH(/test, child1),
	CGROUP_PATH(/test, child2),
	CGROUP_PATH(/test/child1, child1_1),
	CGROUP_PATH(/test/child1, child1_2),
	CGROUP_PATH(/test/child2, child2_1),
	CGROUP_PATH(/test/child2, child2_2),
};

#define N_CGROUPS (sizeof(cgroups)/sizeof(cgroups[0]))
#define N_NON_LEAF_CGROUPS 3

bool mounted_bpffs;
static int duration;

static int read_from_file(const char *path, char *buf, size_t size)
{
	int fd, len;

	fd = open(path, O_RDONLY);
	if (fd < 0) {
		log_err("Open %s", path);
		return -errno;
	}
	len = read(fd, buf, size);
	if (len < 0)
		log_err("Read %s", path);
	else
		buf[len] = 0;
	close(fd);
	return len < 0 ? -errno : 0;
}

static int setup_bpffs(void)
{
	int err;

	/* Mount bpffs */
	err = mount("bpf", BPFFS_ROOT, "bpf", 0, NULL);
	mounted_bpffs = !err;
	if (CHECK(err && errno != EBUSY, "mount bpffs",
	      "failed to mount bpffs at %s (%s)\n", BPFFS_ROOT,
	      strerror(errno)))
		return err;

	/* Create a directory to contain stat files in bpffs */
	err = mkdir(BPFFS_VMSCAN, 0755);
	CHECK(err, "mkdir bpffs", "failed to mkdir %s (%s)\n",
	      BPFFS_VMSCAN, strerror(errno));
	return err;
}

static void cleanup_bpffs(void)
{
	/* Remove created directory in bpffs */
	CHECK(rmdir(BPFFS_VMSCAN), "rmdir", "failed to rmdir %s (%s)\n",
	      BPFFS_VMSCAN, strerror(errno));

	/* Unmount bpffs, if it wasn't already mounted when we started */
	if (mounted_bpffs)
		return;
	CHECK(umount(BPFFS_ROOT), "umount", "failed to unmount bpffs (%s)\n",
	      strerror(errno));
}

static int setup_cgroups(void)
{
	int i, err;

	err = setup_cgroup_environment();
	if (CHECK(err, "setup_cgroup_environment", "failed: %d\n", err))
		return err;

	for (i = 0; i < N_CGROUPS; i++) {
		int fd;

		fd = create_and_get_cgroup(cgroups[i].path);
		if (!ASSERT_GE(fd, 0, "create_and_get_cgroup"))
			return fd;

		cgroups[i].fd = fd;
		cgroups[i].id = get_cgroup_id(cgroups[i].path);
		if (i < N_NON_LEAF_CGROUPS) {
			err = enable_controllers(cgroups[i].path, "memory");
			if (!ASSERT_OK(err, "enable_controllers"))
				return err;
		}
	}
	return 0;
}

static void cleanup_cgroups(void)
{
	for (int i = 0; i < N_CGROUPS; i++)
		close(cgroups[i].fd);
	cleanup_cgroup_environment();
}


static int setup_hierarchy(void)
{
	return setup_bpffs() || setup_cgroups();
}

static void destroy_hierarchy(void)
{
	cleanup_cgroups();
	cleanup_bpffs();
}

static void alloc_anon(size_t size)
{
	char *buf, *ptr;

	buf = malloc(size);
	for (ptr = buf; ptr < buf + size; ptr += PAGE_SIZE)
		*ptr = 0;
	free(buf);
}

static int induce_vmscan(void)
{
	char size[128];
	int i, err;

	/*
	 * Set memory.high for test parent cgroup to 1 MB to throttle
	 * allocations and invoke reclaim in children.
	 */
	snprintf(size, 128, "%d", MB(1));
	err = write_cgroup_file(cgroups[0].path, "memory.high",	size);
	if (!ASSERT_OK(err, "write memory.high"))
		return err;
	/*
	 * In every leaf cgroup, run a memory hog for a few seconds to induce
	 * reclaim then kill it.
	 */
	for (i = N_NON_LEAF_CGROUPS; i < N_CGROUPS; i++) {
		pid_t pid = fork();

		if (pid == 0) {
			/* Join cgroup in the parent process workdir */
			join_parent_cgroup(cgroups[i].path);

			/* Allocate more memory than memory.high */
			alloc_anon(MB(2));
			exit(0);
		} else {
			/* Wait for child to cause reclaim then kill it */
			if (!ASSERT_GT(pid, 0, "fork"))
				return pid;
			sleep(2);
			kill(pid, SIGKILL);
			waitpid(pid, NULL, 0);
		}
	}
	return 0;
}

static unsigned long long get_cgroup_vmscan(unsigned long long cgroup_id,
					    const char *file_name)
{
	char buf[128], path[128];
	unsigned long long vmscan = 0, id = 0;
	int err;

	/* For every cgroup, read the file generated by cgroup_iter */
	snprintf(path, 128, "%s%s", BPFFS_VMSCAN, file_name);
	err = read_from_file(path, buf, 128);
	if (CHECK(err, "read", "failed to read from %s (%s)\n",
		   path, strerror(errno)))
		return 0;

	/* Check the output file formatting */
	ASSERT_EQ(sscanf(buf, "cg_id: %llu, total_vmscan_delay: %llu\n",
			 &id, &vmscan), 2, "output format");

	/* Check that the cgroup_id is displayed correctly */
	ASSERT_EQ(cgroup_id, id, "cgroup_id");
	/* Check that the vmscan reading is non-zero */
	ASSERT_NEQ(vmscan, 0, "vmscan_reading");
	return vmscan;
}

static void check_vmscan_stats(void)
{
	int i;
	unsigned long long vmscan_readings[N_CGROUPS], vmscan_root;

	for (i = 0; i < N_CGROUPS; i++)
		vmscan_readings[i] = get_cgroup_vmscan(cgroups[i].id,
						       cgroups[i].name);

	/* Read stats for root too */
	vmscan_root = get_cgroup_vmscan(CG_ROOT_ID, CG_ROOT_NAME);

	/* Check that child1 == child1_1 + child1_2 */
	ASSERT_EQ(vmscan_readings[1], vmscan_readings[3] + vmscan_readings[4],
		  "child1_vmscan");
	/* Check that child2 == child2_1 + child2_2 */
	ASSERT_EQ(vmscan_readings[2], vmscan_readings[5] + vmscan_readings[6],
		  "child2_vmscan");
	/* Check that test == child1 + child2 */
	ASSERT_EQ(vmscan_readings[0], vmscan_readings[1] + vmscan_readings[2],
		  "test_vmscan");
	/* Check that root >= test */
	ASSERT_GE(vmscan_root, vmscan_readings[1], "root_vmscan");
}

static int setup_cgroup_iter(struct cgroup_vmscan *obj,
			     unsigned long long cgroup_id,
			     const char *file_name)
{
	DECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);
	union bpf_iter_link_info linfo = {};
	struct bpf_link *link;
	char path[128];
	int err;

	/* Create an iter link, parameterized by cgroup id */
	linfo.cgroup.cgroup_id = cgroup_id;
	opts.link_info = &linfo;
	opts.link_info_len = sizeof(linfo);
	link = bpf_program__attach_iter(obj->progs.dump_vmscan, &opts);
	if (!ASSERT_OK_PTR(link, "attach iter"))
		return libbpf_get_error(link);

	/* Pin the link to a bpffs file */
	snprintf(path, 128, "%s%s", BPFFS_VMSCAN, file_name);
	err = bpf_link__pin(link, path);
	CHECK(err, "pin iter", "failed to pin iter at %s", path);
	return err;
}

static int setup_progs(struct cgroup_vmscan **skel)
{
	int i;
	struct bpf_link *link;
	struct cgroup_vmscan *obj;

	obj = cgroup_vmscan__open_and_load();
	if (!ASSERT_OK_PTR(obj, "open_and_load"))
		return libbpf_get_error(obj);

	/* Attach cgroup_iter program that will dump the stats to cgroups */
	for (i = 0; i < N_CGROUPS; i++)
		setup_cgroup_iter(obj, cgroups[i].id, cgroups[i].name);
	/* Also dump stats for root */
	setup_cgroup_iter(obj, CG_ROOT_ID, CG_ROOT_NAME);

	/* Attach rstat flusher */
	link = bpf_program__attach(obj->progs.vmscan_flush);
	if (!ASSERT_OK_PTR(link, "attach rstat"))
		return libbpf_get_error(link);

	/* Attach tracing programs that will calculate vmscan delays */
	link = bpf_program__attach(obj->progs.vmscan_start);
	if (!ASSERT_OK_PTR(obj, "attach raw_tracepoint"))
		return libbpf_get_error(obj);

	link = bpf_program__attach(obj->progs.vmscan_end);
	if (!ASSERT_OK_PTR(obj, "attach raw_tracepoint"))
		return libbpf_get_error(obj);

	*skel = obj;
	return 0;
}

void destroy_progs(struct cgroup_vmscan *skel)
{
	char path[128];
	int i;

	for (i = 0; i < N_CGROUPS; i++) {
		/* Delete files in bpffs that cgroup_iters are pinned in */
		snprintf(path, 128, "%s%s", BPFFS_VMSCAN,
			 cgroups[i].name);
		CHECK(remove(path), "remove", "failed to remove %s (%s)\n",
		      path, strerror(errno));
	}

	/* Delete root file in bpffs */
	snprintf(path, 128, "%s%s", BPFFS_VMSCAN, CG_ROOT_NAME);
	CHECK(remove(path), "remove", "failed to remove %s (%s)\n", path,
	      strerror(errno));
	cgroup_vmscan__destroy(skel);
}

void test_cgroup_hierarchical_stats(void)
{
	struct cgroup_vmscan *skel = NULL;

	if (setup_hierarchy())
		goto hierarchy_cleanup;
	if (setup_progs(&skel))
		goto cleanup;
	if (induce_vmscan())
		goto cleanup;
	check_vmscan_stats();
cleanup:
	destroy_progs(skel);
hierarchy_cleanup:
	destroy_hierarchy();
}
