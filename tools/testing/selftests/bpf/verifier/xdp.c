{
	"XDP, using ifindex from netdev",
	.insns = {
	BPF_MOV64_IMM(BPF_REG_0, 0),
	BPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_1,
		    offsetof(struct xdp_md, ingress_ifindex)),
	BPF_JMP_IMM(BPF_JLT, BPF_REG_2, 1, 1),
	BPF_MOV64_IMM(BPF_REG_0, 1),
	BPF_EXIT_INSN(),
	},
	.result = ACCEPT,
	.prog_type = BPF_PROG_TYPE_XDP,
	.retval = 1,
},
{
	"XDP bpf_packet_pointer offset cannot be > 0xffff",
	.insns = {
	BPF_MOV64_IMM(BPF_REG_2, 0x10000),
	BPF_MOV64_IMM(BPF_REG_3, 42),
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_packet_pointer),
	BPF_MOV64_IMM(BPF_REG_0, 1),
	BPF_EXIT_INSN(),
	},
	.prog_type = BPF_PROG_TYPE_XDP,
	.result_unpriv = REJECT,
	.result = REJECT,
	.errstr = "R2 must be in range [0, 0xffff]",
},
{
	"XDP bpf_packet_pointer len must be constant",
	.insns = {
	BPF_MOV64_IMM(BPF_REG_0, 1),
	BPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_1, offsetof(struct xdp_md, ingress_ifindex)),
	BPF_JMP32_IMM(BPF_JSGE, BPF_REG_2, 0, 1),
	BPF_EXIT_INSN(),
	BPF_JMP32_IMM(BPF_JSLE, BPF_REG_2, 0xffff, 1),
	BPF_EXIT_INSN(),
	BPF_MOV64_REG(BPF_REG_3, BPF_REG_2),
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_packet_pointer),
	BPF_EXIT_INSN(),
	},
	.prog_type = BPF_PROG_TYPE_XDP,
	.result_unpriv = REJECT,
	.result = REJECT,
	.errstr = "R3 is not a known constant",
},
{
	"XDP bpf_packet_pointer len cannot be 0",
	.insns = {
	BPF_MOV64_IMM(BPF_REG_0, 1),
	BPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_1, offsetof(struct xdp_md, ingress_ifindex)),
	BPF_JMP32_IMM(BPF_JSGE, BPF_REG_2, 0, 1),
	BPF_EXIT_INSN(),
	BPF_JMP32_IMM(BPF_JSLE, BPF_REG_2, 0xffff, 1),
	BPF_EXIT_INSN(),
	BPF_MOV64_IMM(BPF_REG_3, 0),
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_packet_pointer),
	BPF_EXIT_INSN(),
	},
	.prog_type = BPF_PROG_TYPE_XDP,
	.result_unpriv = REJECT,
	.result = REJECT,
	.errstr = "R3 must be in range [1, 0xffff]",
},
{
	"XDP bpf_packet_pointer R0 cannot be compared with xdp_md pkt ptr",
	.insns = {
	BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),
	BPF_MOV64_IMM(BPF_REG_2, 0),
	BPF_MOV64_IMM(BPF_REG_3, 42),
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_packet_pointer),
	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
	BPF_EXIT_INSN(),
	BPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_6, offsetof(struct xdp_md, data_end)),
	BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 16),
	BPF_JMP_REG(BPF_JGE, BPF_REG_0, BPF_REG_1, 1),
	BPF_EXIT_INSN(),
	BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, 0),
	BPF_MOV64_IMM(BPF_REG_0, 1),
	BPF_EXIT_INSN(),
	},
	.prog_type = BPF_PROG_TYPE_XDP,
	.result_unpriv = REJECT,
	.result = REJECT,
	.errstr = "R0, R1 pkt pointer comparison prohibited",
},
{
	"XDP bpf_packet_pointer R0 range propagation skips unequal pkt_uid",
	.insns = {
	BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),
	BPF_MOV64_IMM(BPF_REG_2, 0),
	BPF_MOV64_IMM(BPF_REG_3, 1),
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_packet_pointer),
	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
	BPF_EXIT_INSN(),
	BPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_6, offsetof(struct xdp_md, data)),
	BPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_6, offsetof(struct xdp_md, data)),
	BPF_LDX_MEM(BPF_W, BPF_REG_3, BPF_REG_6, offsetof(struct xdp_md, data)),
	BPF_LDX_MEM(BPF_W, BPF_REG_4, BPF_REG_6, offsetof(struct xdp_md, data_end)),
	BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 16),
	BPF_JMP_REG(BPF_JLT, BPF_REG_1, BPF_REG_4, 1),
	BPF_EXIT_INSN(),
	BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_1, -16),
	BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_2, 4),
	BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_3, 8),
	BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, 0),
	BPF_MOV64_IMM(BPF_REG_0, 1),
	BPF_EXIT_INSN(),
	},
	.prog_type = BPF_PROG_TYPE_XDP,
	.result_unpriv = REJECT,
	.result = REJECT,
	.errstr = "invalid access to packet, off=0 size=8, R0(id=0,off=0,r=1)",
},
{
	"XDP clear_all_pkt_pointers doesn't skip pkt_uid != 0",
	.insns = {
	BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),
	BPF_MOV64_IMM(BPF_REG_2, 0),
	BPF_MOV64_IMM(BPF_REG_3, 16),
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_packet_pointer),
	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
	BPF_EXIT_INSN(),
	BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),
	BPF_MOV64_REG(BPF_REG_1, BPF_REG_6),
	BPF_MOV64_IMM(BPF_REG_2, 1),
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_xdp_adjust_tail),
	BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_7, 0),
	BPF_EXIT_INSN(),
	},
	.prog_type = BPF_PROG_TYPE_XDP,
	.result_unpriv = REJECT,
	.result = REJECT,
	.errstr = "R7 invalid mem access 'scalar'",
},
{
	"XDP pkt_uid preserved when resetting range on rX += var",
	.insns = {
	BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),
	BPF_MOV64_IMM(BPF_REG_2, 0),
	BPF_MOV64_IMM(BPF_REG_3, 16),
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_packet_pointer),
	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
	BPF_EXIT_INSN(),
	BPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_6, offsetof(struct xdp_md, ingress_ifindex)),
	BPF_JMP32_IMM(BPF_JGE, BPF_REG_1, 0, 1),
	BPF_EXIT_INSN(),
	BPF_JMP32_IMM(BPF_JLE, BPF_REG_1, 4, 1),
	BPF_EXIT_INSN(),
	BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_0),
	BPF_LDX_MEM(BPF_W, BPF_REG_0, BPF_REG_6, offsetof(struct xdp_md, data_end)),
	BPF_JMP_REG(BPF_JLT, BPF_REG_1, BPF_REG_0, 1),
	BPF_EXIT_INSN(),
	BPF_EXIT_INSN(),
	},
	.prog_type = BPF_PROG_TYPE_XDP,
	.result_unpriv = REJECT,
	.result = REJECT,
	.errstr = "R1, R0 pkt pointer comparison prohibited",
},
